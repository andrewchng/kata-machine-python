import re
import importlib
import os
from types import ModuleType
from src.types import BinaryNode

def count_days():
    idx = 0
    def contains_day_patter(text: str):
        pattern = r'day\d+'
        if re.search(pattern, text):
            return True
        else :
            return False

    path = "./src"
    for _, dirs, _ in os.walk(path):
        for dir in dirs:
            if contains_day_patter(dir) :
                idx += 1
    return idx

def dynamic_import(kata_name: str) -> ModuleType :
    module_name = f"src.day{count_days()}.{kata_name}"
    module = importlib.import_module(module_name)
    return module

# need to revise this part, generated by llama3

def insert_node(root, value):
    # print(f"inserting.... {value}")
    if root is None:  # Empty tree, create a new node
        # print(f"insert node {value} \n")
        return BinaryNode(value)
    elif value <= root.value:  # Value is less than current node's value
        # print(f"traverse left of {root.value}")
        root.left = insert_node(root.left, value)  # Recursively insert left child
    else:
        # print(f"traverse right of {root.value}")
        root.right = insert_node(root.right, value)  # Recursively insert right child
    return root

def insert_node_left(root, value):
    if root is None:  # Empty tree, create a new node
        return BinaryNode(value)
    root.left = insert_node_left(root.left, value)  # Recursively insert left child
    return root

def insert_node_right(root, value):
    if root is None:  # Empty tree, create a new node
        return BinaryNode(value)
    root.right = insert_node_right(root.right, value)  # Recursively insert left child
    return root

# def print_tree(root):
#     if root is None:  # Base case: empty tree
#         return
#     print_tree(root.left)  # Recursively traverse left subtree
#     print(root.value)
#     print_tree(root.right)  # Recursively traverse right subtree

def create_tree():
    root = BinaryNode(5)
    insert_node(root, 2)  # Insert node with value 2 (left child of 5)
    insert_node(root, 7)  # Insert node with value 7 (right child of 5)
    insert_node(root, 3)  # Insert node with value 3 (left child of 2)
    insert_node(root, 6)  # Insert node with value 6 (right child of 2)
    insert_node(root, 8)  # Insert node with value 8 (right child of 7)
    return root

def get_path_in_order(root, path : list[int]):
    if root is None:
        return
    get_path_in_order(root.left, path)
    path.append(root.value)
    get_path_in_order(root.right, path)

def get_path_post_order(root, path : list[int]):
    if root is None:
        return
    get_path_post_order(root.left, path)
    get_path_post_order(root.right, path)
    path.append(root.value)

def get_path_pre_order(root, path : list[int]):
    if root is None:
        return
    path.append(root.value)
    get_path_pre_order(root.left, path)
    get_path_pre_order(root.right, path)

# def print_tree(root):
#     queue = [root]
#     while len(queue) > 0:
#         node = queue.pop(0)
#         if node is None:
#             continue
#         print(node.value)
#         print(f"{node.left}, {node.right}")
#         queue.append(node.left)
#         queue.append(node.right)

def print_binary_tree(root, level=0):
    if root is not None:
        print_binary_tree(root.right, level + 1) 
        print('     ' * level +str(root.value) + "-|")
        print_binary_tree(root.left, level + 1)
    else:
        print('     ' * level + "x")
    
    


